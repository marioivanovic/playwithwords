{"ast":null,"code":"import { WebPlugin } from '@capacitor/core';\n\nfunction resolve(path) {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix = [];\n  posix.forEach(item => {\n    if (item === '..' && newPosix.length > 0 && newPosix[newPosix.length - 1] !== '..') {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n  return newPosix.join('/');\n}\n\nfunction isPathParent(parent, children) {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n  return parent !== children && pathsA.every((value, index) => value === pathsB[index]);\n}\n\nexport class FilesystemWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.DB_VERSION = 1;\n    this.DB_NAME = 'Disc';\n    this._writeCmds = ['add', 'put', 'delete'];\n  }\n\n  async initDb() {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n\n      request.onerror = () => reject(request.error);\n\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event) {\n    const eventTarget = event.target;\n    const db = eventTarget.result;\n\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default:\n        {\n          if (db.objectStoreNames.contains('FileStorage')) {\n            db.deleteObjectStore('FileStorage');\n          }\n\n          const store = db.createObjectStore('FileStorage', {\n            keyPath: 'path'\n          });\n          store.createIndex('by_folder', 'folder');\n        }\n    }\n  }\n\n  async dbRequest(cmd, args) {\n    const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then(conn => {\n      return new Promise((resolve, reject) => {\n        const tx = conn.transaction(['FileStorage'], readFlag);\n        const store = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n\n        req.onsuccess = () => resolve(req.result);\n\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(indexName, cmd, args) {\n    const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then(conn => {\n      return new Promise((resolve, reject) => {\n        const tx = conn.transaction(['FileStorage'], readFlag);\n        const store = tx.objectStore('FileStorage');\n        const index = store.index(indexName);\n        const req = index[cmd](...args);\n\n        req.onsuccess = () => resolve(req.result);\n\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  getPath(directory, uriPath) {\n    const cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear() {\n    const conn = await this.initDb();\n    const tx = conn.transaction(['FileStorage'], 'readwrite');\n    const store = tx.objectStore('FileStorage');\n    store.clear();\n  }\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n\n\n  async readFile(options) {\n    const path = this.getPath(options.directory, options.path); // const encoding = options.encoding;\n\n    const entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) throw Error('File does not exist.');\n    return {\n      data: entry.content ? entry.content : ''\n    };\n  }\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n\n\n  async writeFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    const data = options.data;\n    const doRecursive = options.recursive;\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (occupiedEntry && occupiedEntry.type === 'directory') throw Error('The supplied path is a directory.');\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive\n        });\n      }\n    }\n\n    const now = Date.now();\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: now,\n      mtime: now,\n      content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path\n    };\n  }\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n\n\n  async appendFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    let data = options.data; // const encoding = options.encoding;\n\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const now = Date.now();\n    let ctime = now;\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (occupiedEntry && occupiedEntry.type === 'directory') throw Error('The supplied path is a directory.');\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true\n        });\n      }\n    }\n\n    if (occupiedEntry !== undefined) {\n      data = occupiedEntry.content + data;\n      ctime = occupiedEntry.ctime;\n    }\n\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n\n\n  async deleteFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    const entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n    await this.dbRequest('delete', [path]);\n  }\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n\n\n  async mkdir(options) {\n    const path = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined) throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined) throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive\n      });\n    }\n\n    const now = Date.now();\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n\n\n  async rmdir(options) {\n    const {\n      path,\n      directory,\n      recursive\n    } = options;\n    const fullPath = this.getPath(directory, path);\n    const entry = await this.dbRequest('get', [fullPath]);\n    if (entry === undefined) throw Error('Folder does not exist.');\n    if (entry.type !== 'directory') throw Error('Requested path is not a directory');\n    const readDirResult = await this.readdir({\n      path,\n      directory\n    });\n    if (readDirResult.files.length !== 0 && !recursive) throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry}`;\n      const entryObj = await this.stat({\n        path: entryPath,\n        directory\n      });\n\n      if (entryObj.type === 'file') {\n        await this.deleteFile({\n          path: entryPath,\n          directory\n        });\n      } else {\n        await this.rmdir({\n          path: entryPath,\n          directory,\n          recursive\n        });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n\n\n  async readdir(options) {\n    const path = this.getPath(options.directory, options.path);\n    const entry = await this.dbRequest('get', [path]);\n    if (options.path !== '' && entry === undefined) throw Error('Folder does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n    const names = entries.map(e => {\n      return e.substring(path.length + 1);\n    });\n    return {\n      files: names\n    };\n  }\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n\n\n  async getUri(options) {\n    const path = this.getPath(options.directory, options.path);\n    let entry = await this.dbRequest('get', [path]);\n\n    if (entry === undefined) {\n      entry = await this.dbRequest('get', [path + '/']);\n    }\n\n    return {\n      uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path\n    };\n  }\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n\n\n  async stat(options) {\n    const path = this.getPath(options.directory, options.path);\n    let entry = await this.dbRequest('get', [path]);\n\n    if (entry === undefined) {\n      entry = await this.dbRequest('get', [path + '/']);\n    }\n\n    if (entry === undefined) throw Error('Entry does not exist.');\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path\n    };\n  }\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n\n\n  async rename(options) {\n    return this._copy(options, true);\n  }\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n\n\n  async copy(options) {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions() {\n    return {\n      publicStorage: 'granted'\n    };\n  }\n\n  async checkPermissions() {\n    return {\n      publicStorage: 'granted'\n    };\n  }\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n\n\n  async _copy(options, doRename = false) {\n    let {\n      toDirectory\n    } = options;\n    const {\n      to,\n      from,\n      directory: fromDirectory\n    } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    } // If no \"to\" directory is provided, use the \"from\" directory\n\n\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to); // Test that the \"to\" and \"from\" locations are different\n\n    if (fromPath === toPath) {\n      return;\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    } // Check the state of the \"to\" location\n\n\n    let toObj;\n\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/'); // Check the containing directory of the \"to\" location exists\n\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    } // Cannot overwrite a directory\n\n\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    } // Ensure the \"from\" object exists\n\n\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory\n    }); // Set the mtime/ctime of the supplied path\n\n    const updateTime = async (path, ctime, mtime) => {\n      const fullPath = this.getPath(toDirectory, path);\n      const entry = await this.dbRequest('get', [fullPath]);\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file':\n        {\n          // Read the file\n          const file = await this.readFile({\n            path: from,\n            directory: fromDirectory\n          }); // Optionally remove the file\n\n          if (doRename) {\n            await this.deleteFile({\n              path: from,\n              directory: fromDirectory\n            });\n          } // Write the file to the new location\n\n\n          await this.writeFile({\n            path: to,\n            directory: toDirectory,\n            data: file.data\n          }); // Copy the mtime/ctime of a renamed file\n\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          } // Resolve promise\n\n\n          return;\n        }\n\n      case 'directory':\n        {\n          if (toObj) {\n            throw Error('Cannot move a directory over an existing object');\n          }\n\n          try {\n            // Create the to directory\n            await this.mkdir({\n              path: to,\n              directory: toDirectory,\n              recursive: false\n            }); // Copy the mtime/ctime of a renamed directory\n\n            if (doRename) {\n              await updateTime(to, ctime, fromObj.mtime);\n            }\n          } catch (e) {} // ignore\n          // Iterate over the contents of the from location\n\n\n          const contents = (await this.readdir({\n            path: from,\n            directory: fromDirectory\n          })).files;\n\n          for (const filename of contents) {\n            // Move item from the from directory to the to directory\n            await this._copy({\n              from: `${from}/${filename}`,\n              to: `${to}/${filename}`,\n              directory: fromDirectory,\n              toDirectory\n            }, doRename);\n          } // Optionally remove the original from directory\n\n\n          if (doRename) {\n            await this.rmdir({\n              path: from,\n              directory: fromDirectory\n            });\n          }\n        }\n    }\n  }\n\n}\nFilesystemWeb._debug = true;","map":{"version":3,"sources":["../../src/web.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebPlugin } from '@capacitor/core';\n\nimport type {\n  AppendFileOptions,\n  CopyOptions,\n  DeleteFileOptions,\n  FilesystemPlugin,\n  GetUriOptions,\n  GetUriResult,\n  MkdirOptions,\n  PermissionStatus,\n  ReadFileOptions,\n  ReadFileResult,\n  ReaddirOptions,\n  ReaddirResult,\n  RenameOptions,\n  RmdirOptions,\n  StatOptions,\n  StatResult,\n  WriteFileOptions,\n  WriteFileResult,\n  Directory,\n} from './definitions';\n\nfunction resolve(path: string): string {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix: string[] = [];\n\n  posix.forEach(item => {\n    if (\n      item === '..' &&\n      newPosix.length > 0 &&\n      newPosix[newPosix.length - 1] !== '..'\n    ) {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n\n  return newPosix.join('/');\n}\nfunction isPathParent(parent: string, children: string): boolean {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n\n  return (\n    parent !== children &&\n    pathsA.every((value, index) => value === pathsB[index])\n  );\n}\n\nexport class FilesystemWeb extends WebPlugin implements FilesystemPlugin {\n  DB_VERSION = 1;\n  DB_NAME = 'Disc';\n\n  private _writeCmds: string[] = ['add', 'put', 'delete'];\n  private _db?: IDBDatabase;\n  static _debug = true;\n  async initDb(): Promise<IDBDatabase> {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event: IDBVersionChangeEvent): void {\n    const eventTarget = event.target as IDBOpenDBRequest;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default: {\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n        store.createIndex('by_folder', 'folder');\n      }\n    }\n  }\n\n  async dbRequest(cmd: string, args: any[]): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: any = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(\n    indexName: string,\n    cmd: string,\n    args: [any],\n  ): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: IDBObjectStore = tx.objectStore('FileStorage');\n        const index: any = store.index(indexName);\n        const req = index[cmd](...args) as any;\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  private getPath(\n    directory: Directory | undefined,\n    uriPath: string | undefined,\n  ): string {\n    const cleanedUriPath =\n      uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear(): Promise<void> {\n    const conn: IDBDatabase = await this.initDb();\n    const tx: IDBTransaction = conn.transaction(['FileStorage'], 'readwrite');\n    const store: IDBObjectStore = tx.objectStore('FileStorage');\n    store.clear();\n  }\n\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options: ReadFileOptions): Promise<ReadFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    return { data: entry.content ? entry.content : '' };\n  }\n\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options: WriteFileOptions): Promise<WriteFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    const data = options.data;\n    const doRecursive = options.recursive;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive,\n        });\n      }\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: now,\n      mtime: now,\n      content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data,\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path,\n    };\n  }\n\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options: AppendFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    // const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const now = Date.now();\n    let ctime = now;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true,\n        });\n      }\n    }\n\n    if (occupiedEntry !== undefined) {\n      data = occupiedEntry.content + data;\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options: DeleteFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n      IDBKeyRange.only(path),\n    ]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n\n    await this.dbRequest('delete', [path]);\n  }\n\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options: MkdirOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined)\n      throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined)\n      throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive,\n      });\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options: RmdirOptions): Promise<void> {\n    const { path, directory, recursive } = options;\n    const fullPath: string = this.getPath(directory, path);\n\n    const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n\n    if (entry === undefined) throw Error('Folder does not exist.');\n\n    if (entry.type !== 'directory')\n      throw Error('Requested path is not a directory');\n\n    const readDirResult = await this.readdir({ path, directory });\n\n    if (readDirResult.files.length !== 0 && !recursive)\n      throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry}`;\n      const entryObj = await this.stat({ path: entryPath, directory });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({ path: entryPath, directory });\n      } else {\n        await this.rmdir({ path: entryPath, directory, recursive });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options: ReaddirOptions): Promise<ReaddirResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (options.path !== '' && entry === undefined)\n      throw Error('Folder does not exist.');\n\n    const entries: string[] = await this.dbIndexRequest(\n      'by_folder',\n      'getAllKeys',\n      [IDBKeyRange.only(path)],\n    );\n    const names = entries.map(e => {\n      return e.substring(path.length + 1);\n    });\n    return { files: names };\n  }\n\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options: GetUriOptions): Promise<GetUriResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    return {\n      uri: entry?.path || path,\n    };\n  }\n\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options: StatOptions): Promise<StatResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path,\n    };\n  }\n\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options: RenameOptions): Promise<void> {\n    return this._copy(options, true);\n  }\n\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options: CopyOptions): Promise<void> {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  private async _copy(options: CopyOptions, doRename = false): Promise<void> {\n    let { toDirectory } = options;\n    const { to, from, directory: fromDirectory } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return;\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory,\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory,\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory,\n    });\n\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path: string, ctime: number, mtime: number) => {\n      const fullPath: string = this.getPath(toDirectory, path);\n      const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file': {\n        // Read the file\n        const file = await this.readFile({\n          path: from,\n          directory: fromDirectory,\n        });\n\n        // Optionally remove the file\n        if (doRename) {\n          await this.deleteFile({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n\n        // Write the file to the new location\n        await this.writeFile({\n          path: to,\n          directory: toDirectory,\n          data: file.data,\n        });\n\n        // Copy the mtime/ctime of a renamed file\n        if (doRename) {\n          await updateTime(to, ctime, fromObj.mtime);\n        }\n\n        // Resolve promise\n        return;\n      }\n      case 'directory': {\n        if (toObj) {\n          throw Error('Cannot move a directory over an existing object');\n        }\n\n        try {\n          // Create the to directory\n          await this.mkdir({\n            path: to,\n            directory: toDirectory,\n            recursive: false,\n          });\n\n          // Copy the mtime/ctime of a renamed directory\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n        } catch (e) {\n          // ignore\n        }\n\n        // Iterate over the contents of the from location\n        const contents = (\n          await this.readdir({\n            path: from,\n            directory: fromDirectory,\n          })\n        ).files;\n\n        for (const filename of contents) {\n          // Move item from the from directory to the to directory\n          await this._copy(\n            {\n              from: `${from}/${filename}`,\n              to: `${to}/${filename}`,\n              directory: fromDirectory,\n              toDirectory,\n            },\n            doRename,\n          );\n        }\n\n        // Optionally remove the original from directory\n        if (doRename) {\n          await this.rmdir({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n      }\n    }\n  }\n}\n\ninterface EntryObj {\n  path: string;\n  folder: string;\n  type: string;\n  size: number;\n  ctime: number;\n  mtime: number;\n  uri?: string;\n  content?: string;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}